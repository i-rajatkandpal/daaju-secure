# SecurePass - Learning Path & Implementation Guide

## üéØ Project Goal
Build a professional-grade password hashing library that demonstrates:
- Deep understanding of cryptographic concepts
- Clean Java architecture and API design
- Security-first thinking
- Production-ready code quality

**Resume Impact:** Shows employers you understand security, not just "used bcrypt"

---

## üìö PHASE 1: Foundation Theory (Week 1)

### Day 1-2: Understanding Password Security

**Learn These Concepts:**

1. **Why we hash passwords (not encrypt)**
   - Encryption is reversible (has a key)
   - Hashing is one-way (irreversible)
   - We never need the original password back

2. **What makes a hash function good for passwords?**
   - Slow/expensive (prevents brute force)
   - Deterministic (same input = same output)
   - Avalanche effect (tiny change = totally different hash)

3. **Critical concepts:**
   - **Salt:** Random data added to password before hashing
   - **Pepper:** Secret value added (like salt, but kept secret)
   - **Iterations/Work Factor:** How many times to repeat hashing
   - **Rainbow Tables:** Pre-computed hash databases (defeated by salts)
   - **Timing Attacks:** Comparing hashes in constant time

**üìñ Resources to Study:**
- Google: "OWASP Password Storage Cheat Sheet"
- Read: "How NOT to Store Passwords" (Coding Horror blog)
- Video: Search "password hashing explained" on YouTube

**‚úÖ TASK 1.1: Theory Quiz (Answer These)**
Write down answers in your own words:
1. Why can't we just use MD5 or SHA-256 for passwords?
2. What is a salt and why is it critical?
3. What's the difference between salt and pepper?
4. Why do we use iterations/rounds in password hashing?
5. What is a timing attack in password verification?

**‚úÖ TASK 1.2: Research Assignment**
Compare these algorithms (make a table):
- PBKDF2
- bcrypt
- scrypt
- Argon2

For each: Year created, main purpose, key parameters, pros/cons

---

### Day 3-4: Java Cryptography Basics

**Learn These Java APIs:**

1. **`java.security.SecureRandom`**
   - Why NOT to use `Random()` for security
   - How to generate cryptographically secure random bytes

2. **`javax.crypto.SecretKeyFactory`**
   - Key derivation functions
   - PBKDF2 implementation in Java

3. **`java.security.MessageDigest`**
   - Hashing functions (SHA-256, etc.)
   - Updating digests, getting output

4. **Base64 encoding**
   - Why we encode binary data
   - `java.util.Base64` usage

**üìñ Resources:**
- Oracle Java Cryptography Architecture docs
- Baeldung: "Java SecureRandom" tutorial
- Baeldung: "PBKDF2 in Java"

**‚úÖ TASK 1.3: Code Experiments**
Create `CryptoBasics.java` and implement:

```java
// 1. Generate 32 random bytes
public static byte[] generateRandomBytes(int length) {
    // Use SecureRandom
}

// 2. Hash a string with SHA-256
public static byte[] sha256(String input) {
    // Use MessageDigest
}

// 3. Encode bytes to Base64 string
public static String toBase64(byte[] bytes) {
    // Use Base64
}

// 4. Test that same input gives same hash
public static void testDeterministic() {
    // Hash "password" twice, verify equal
}
```

Test all functions in `main()`. Show me your output!

---

### Day 5-7: PBKDF2 Deep Dive

**Learn:**
- PBKDF2 algorithm internals
- Parameters: iterations, salt length, hash function
- How to use Java's built-in PBKDF2

**üìñ Resources:**
- RFC 2898 (PBKDF2 specification) - skim it
- Baeldung: "Hashing Passwords in Java with PBKDF2"

**‚úÖ TASK 1.4: Implement PBKDF2 Hasher**

Create `PBKDF2Demo.java`:

```java
public class PBKDF2Demo {
    
    // Hash a password with PBKDF2
    public static String hashPassword(String password) 
        throws Exception {
        // 1. Generate 16-byte salt with SecureRandom
        // 2. Use PBKDF2WithHmacSHA256, 120,000 iterations
        // 3. Generate 256-bit (32-byte) hash
        // 4. Combine salt + hash and encode to Base64
        // 5. Return formatted string: "salt:hash"
    }
    
    // Verify a password against stored hash
    public static boolean verifyPassword(
        String password, 
        String storedHash
    ) throws Exception {
        // 1. Parse salt and hash from storedHash string
        // 2. Hash the input password with same salt
        // 3. Compare hashes in CONSTANT TIME
        // 4. Return true if match
    }
    
    // IMPORTANT: Constant-time comparison
    public static boolean constantTimeEquals(
        byte[] a, 
        byte[] b
    ) {
        // Implement timing-safe comparison
        // Hint: Always compare ALL bytes
    }
}
```

**Success Criteria:**
- Can hash "password123" and get different output each time (different salts)
- Can verify correct password returns true
- Can verify wrong password returns false
- `constantTimeEquals` always takes same time regardless of input

**üìù Week 1 Checkpoint:**
Show me:
1. Your theory quiz answers
2. Algorithm comparison table
3. Working `CryptoBasics.java` output
4. Working `PBKDF2Demo.java` with test cases

---

## üèóÔ∏è PHASE 2: Architecture & Design (Week 2)

### Day 8-9: Clean Architecture Design

**Learn:**
- Builder pattern
- Fluent interfaces
- Immutable objects
- Factory pattern
- Strategy pattern

**üìñ Resources:**
- "Effective Java" by Joshua Bloch (Chapters on builders, immutability)
- Refactoring Guru: Design Patterns

**‚úÖ TASK 2.1: Design Your API**

Write a `API_DESIGN.md` document with:

1. **How you want users to use your library:**
```java
// Show 3-5 example code snippets
// Make it as simple and beautiful as possible
```

2. **List all classes you'll need:**
   - What is each class responsible for?
   - How do they interact?

3. **Choose a name for your library**
   - Something professional and memorable

**‚úÖ TASK 2.2: Create Project Structure**

Set up Maven/Gradle project:
```
your-library/
‚îú‚îÄ‚îÄ pom.xml or build.gradle
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ src/main/java/...
‚îî‚îÄ‚îÄ src/test/java/...
```

Create empty skeleton classes based on your design.

---

### Day 10-11: Implement Core Interfaces

**‚úÖ TASK 2.3: Build Core Abstractions**

Implement these key classes:

1. **`PasswordHash`** - Immutable result object
2. **`HashConfiguration`** - Builder for config
3. **`Hasher`** - Interface for hashing algorithms
4. **`SaltGenerator`** - Secure salt generation

Each class must have:
- Javadoc comments
- Input validation
- Unit tests

**‚úÖ TASK 2.4: Implement PBKDF2 Properly**

Refactor your PBKDF2Demo into proper classes:
- `PBKDF2Hasher implements Hasher`
- Support configurable iterations
- Proper error handling
- Comprehensive tests

---

### Day 12-14: Hash Format & Serialization

**Learn:**
- Modular Crypt Format (MCF)
- String parsing techniques
- Regex for validation

**‚úÖ TASK 2.5: Implement Hash Formatter**

Create a standard format for storing hashes:
```
$pbkdf2-sha256$i=120000,l=32$base64-salt$base64-hash
```

Implement:
- `toString()` - serialize PasswordHash to string
- `fromString()` - parse string back to PasswordHash
- Validation and error handling

---

## üöÄ PHASE 3: Advanced Features (Week 3-4)

### Week 3: Multiple Algorithms

**‚úÖ TASK 3.1: Add BCrypt Support**
- Use jBCrypt library as dependency
- Implement `BCryptHasher implements Hasher`
- Support bcrypt work factor configuration

**‚úÖ TASK 3.2: Algorithm Factory**
- Create factory to select algorithm
- Support algorithm migration

### Week 4: Security Extras

**‚úÖ TASK 4.1: Password Strength Validator**
- Check length, character types
- Common password detection
- Entropy calculation

**‚úÖ TASK 4.2: Secure Token Generator**
- Random token generation
- Hex/Base64 encoding options

---

## üìä PHASE 4: Polish & Documentation (Week 5-6)

**‚úÖ TASK 5.1: Comprehensive Testing**
- Unit tests (90%+ coverage)
- Security-specific tests
- Performance benchmarks

**‚úÖ TASK 5.2: Documentation**
- Professional README
- API documentation
- Usage examples
- Security considerations guide

**‚úÖ TASK 5.3: Code Quality**
- Run static analysis (SpotBugs, PMD)
- Fix all warnings
- Add CI/CD (GitHub Actions)

---

## üéì Learning Checkpoints

After each phase, you must:
1. **Show me your code**
2. **Explain your design decisions**
3. **Demonstrate it works**
4. **Ask questions about what confused you**

I'll review, give feedback, and guide you to the next phase.

---

## üìù Resume-Ready Checklist

By the end, your project should have:
- ‚úÖ Clean, well-documented code on GitHub
- ‚úÖ Comprehensive README with examples
- ‚úÖ 85%+ test coverage
- ‚úÖ Professional package structure
- ‚úÖ Maven Central compatible (optional)
- ‚úÖ Security considerations documented
- ‚úÖ Performance benchmarks included

**Resume Bullet Points You Can Use:**
- "Designed and implemented a Java cryptographic library for secure password hashing using PBKDF2 and bcrypt"
- "Applied security best practices including constant-time comparison, secure random generation, and configurable work factors"
- "Achieved 90%+ test coverage with comprehensive unit and integration tests"
- "Demonstrated deep understanding of cryptographic principles and Java security APIs"

---

## üö¶ Ready to Start?

**Your First Assignment:**
Complete Phase 1, Day 1-2 theory and come back with:
1. Answers to the 5 theory questions
2. Your algorithm comparison table
3. Any questions you have

Take your time - understanding the theory is MORE important than rushing to code!

Let me know when you're done with the first assignment! üéØ